<?xml version="1.0"?>
<project name="SensorIK" version="2.1.0.440">
    <desc><![CDATA[]]></desc>
    <pattr name="Apply default power mode">0</pattr>
    <pattr name="Board">None</pattr>
    <pattr name="Chip name">CC1310</pattr>
    <pattr name="Chip package">QFN32 5x5 RHB</pattr>
    <pattr name="Chip revision">-</pattr>
    <pattr name="Clock in active mode">0</pattr>
    <pattr name="Code prefix"></pattr>
    <pattr name="Default power mode">0</pattr>
    <pattr name="Operating system">TI-RTOS</pattr>
    <pattr name="Output directory">./source</pattr>
    <pattr name="RTC tick interval (16.16 format)">2000</pattr>
    <pattr name="Run-time logging UART RX pin"></pattr>
    <pattr name="Run-time logging UART TX pin"></pattr>
    <task name="AnalyseIK">
        <desc><![CDATA[]]></desc>
        <tattr name="AP_IK_ALARM_FLAG" type="dec" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="AP_IK_DISTURB_FLAG" type="dec" content="const" scope="task" min="0" max="65535">1</tattr>
        <tattr name="AP_IK_SETUP_FLAG" type="dec" content="const" scope="task" min="0" max="65535">128</tattr>
        <tattr name="AP_IK_TESTMODE_FLAG" type="dec" content="const" scope="task" min="0" max="65535">64</tattr>
        <tattr name="BV_ADC_WINDOW_HIGH" type="dec" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="BV_ADC_WINDOW_LOW" type="dec" content="const" scope="task" min="0" max="65535">1</tattr>
        <tattr name="FLAG_PIR_OK" type="dec" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="FLAG_UCP_OK" type="dec" content="const" scope="task" min="0" max="65535">1</tattr>
        <tattr name="LIGHT_ACC_THRESHOLD" type="dec" content="const" scope="task" min="0" max="65535">30</tattr>
        <tattr name="LIGHT_RESTORE_PERIOD" type="dec" content="const" scope="task" min="0" max="65535">400</tattr>
        <tattr name="LIGHT_THRESHOLD" type="dec" content="const" scope="task" min="0" max="65535">200</tattr>
        <tattr name="MINUS_ONE" type="dec" content="const" scope="task" min="-32768" max="32767">-1</tattr>
        <tattr name="OPAMP_AVERAGING_SAMPLES" type="dec" content="const" scope="task" min="0" max="65535">128</tattr>
        <tattr name="OPAMP_TRANSIENT_PERIOD" type="dec" content="const" scope="task" min="0" max="65535">11000</tattr>
        <tattr name="PERIOD_1S" type="dec" content="const" scope="task" min="0" max="65535">50</tattr>
        <tattr name="PERIOD_5S" type="dec" content="const" scope="task" min="0" max="65535">250</tattr>
        <tattr name="PIR_ALARM_TIME" type="dec" content="const" scope="task" min="0" max="65535">125</tattr>
        <tattr name="PIR_AVERAGING_TIME" type="dec" content="const" scope="task" min="0" max="65535">128</tattr>
        <tattr name="PIR_CP" type="dec" content="const" scope="task" min="0" max="65535">2000</tattr>
        <tattr name="PIR_IDLE_PERIOD" type="dec" content="const" scope="task" min="0" max="65535">400</tattr>
        <tattr name="PIR_NOISE_THRESHOLD" type="dec" content="const" scope="task" min="0" max="65535">57</tattr>
        <tattr name="PIR_SENS" type="dec" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="PIR_SLOPE_THRESHOLD" type="dec" content="const" scope="task" min="0" max="65535">960</tattr>
        <tattr name="PIR_THRESHOLD" type="dec" content="const" scope="task" min="0" max="65535">172</tattr>
        <tattr name="STATE_INIT" type="dec" content="const" scope="task" min="0" max="65535">0</tattr>
        <tattr name="STATE_OPERATE_3" type="dec" content="const" scope="task" min="0" max="65535">4</tattr>
        <tattr name="STATE_PIR_AVERAGE_1" type="dec" content="const" scope="task" min="0" max="65535">2</tattr>
        <tattr name="STATE_SLEEP" type="dec" content="const" scope="task" min="0" max="65535">5</tattr>
        <tattr name="STATE_WAIT_OP_TRANSIENT_0" type="dec" content="const" scope="task" min="0" max="65535">1</tattr>
        <tattr name="STATE_WAIT_PIR_TRANSIENT_2" type="dec" content="const" scope="task" min="0" max="65535">3</tattr>
        <tattr name="UINT16_MAX" type="dec" content="const" scope="task" min="0" max="65535">65535</tattr>
        <tattr name="ULED_BUF_SIZE" type="dec" content="const" scope="task" min="0" max="65535">16</tattr>
        <tattr name="cfg.CntMinusOne" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.Uacc" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.Uledi" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.adcWindowHigh" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.adcWindowLow" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.dUled" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="cfg.flags" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.count" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.isArmed" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.isLogMode" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="input.isTestMode" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.LightThrCounter10" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.PirPulseCounter" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.Uledi" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.Uph" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.Upirav" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.Upiri" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.Upl" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="output.dUled" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Downtimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.DowntimerRun" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.IKstate" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.LightThrCounter" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.PirAveragingSamples" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.PirOutOfPipe" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.PirPulseCounter" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.PirPulsePresense" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uacch" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uaccl" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Ubat" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Ucp" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uledi" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uledidx" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uledmax" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uledmin" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Uph" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Upiri" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Upiri1" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Upiri2" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Upl" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.Ut" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.aUled" size="ULED_BUF_SIZE" type="dec" content="struct_array" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.absdU" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.absdU1" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.adcdowntimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.alarmdowntimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.alarmdowntimerrun" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.dUled" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.deltaU" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.deltaU1" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.idledowntimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.idledowntimerrun" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.lightdowntimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.lightdowntimerrun" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.maxUh" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.maxUl" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.maxslope" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.slope1" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.slope2" type="dec" content="struct" scope="task" min="-32768" max="32767">0</tattr>
        <tattr name="state.state" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.thrdowntimer" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <tattr name="state.thrdowntimerrun" type="dec" content="struct" scope="task" min="0" max="65535">0</tattr>
        <resource_ref name="ADC" enabled="1"/>
        <resource_ref name="AON Domain Functionality" enabled="0"/>
        <resource_ref name="Accumulator-Based Math" enabled="0"/>
        <resource_ref name="Analog Open-Drain Pins" enabled="0"/>
        <resource_ref name="Analog Open-Source Pins" enabled="0"/>
        <resource_ref name="Analog Pins" enabled="1">
            <io_usage name="IR_OUT" label="To ADC from IKOut">
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO12</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
            <io_usage name="BATTERY" label="BATTERY voltage ADC IN">
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO7</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
            <io_usage name="TEMPERAT" label="Ain thermosensor">
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO13</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
            <io_usage name="LED_RED_AIN" label="to ADC from LEDRED for light measurement">
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO10</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="COMPA" enabled="0"/>
        <resource_ref name="COMPA Event Trigger" enabled="0"/>
        <resource_ref name="COMPB" enabled="0"/>
        <resource_ref name="COMPB Event Trigger" enabled="0"/>
        <resource_ref name="Delay Insertion" enabled="1"/>
        <resource_ref name="Differential Output Pins" enabled="0"/>
        <resource_ref name="Digital Input Pins" enabled="0"/>
        <resource_ref name="Digital Open-Drain Pins" enabled="0"/>
        <resource_ref name="Digital Open-Source Pins" enabled="0"/>
        <resource_ref name="Digital Output Pins" enabled="1">
            <io_usage name="PIR_off" label="PIR On pin by 0">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output value on initialization">1</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO4</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="BT_ON_P" label="Key for thermistor divider">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO14</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
            <io_usage name="LED_RED_0" label="Logical 0 for correct ADC from LEDREDAIN">
                <uattr name="Configuration on uninitialization">-1</uattr>
                <uattr name="Output value on initialization">0</uattr>
                <uattr name="Pin count">0</uattr>
                <uattr name="Pin/0000">DIO0</uattr>
                <uattr name="Pin/0001"></uattr>
                <uattr name="Pin/0002"></uattr>
                <uattr name="Pin/0003"></uattr>
                <uattr name="Pin/0004"></uattr>
                <uattr name="Pin/0005"></uattr>
                <uattr name="Pin/0006"></uattr>
                <uattr name="Pin/0007"></uattr>
                <uattr name="Pin/0008"></uattr>
                <uattr name="Pin/0009"></uattr>
                <uattr name="Pin/0010"></uattr>
                <uattr name="Pin/0011"></uattr>
                <uattr name="Pin/0012"></uattr>
                <uattr name="Pin/0013"></uattr>
                <uattr name="Pin/0014"></uattr>
                <uattr name="Pin/0015"></uattr>
                <uattr name="Pin/0016"></uattr>
                <uattr name="Pin/0017"></uattr>
                <uattr name="Pin/0018"></uattr>
                <uattr name="Pin/0019"></uattr>
                <uattr name="Pin/0020"></uattr>
                <uattr name="Pin/0021"></uattr>
                <uattr name="Pin/0022"></uattr>
                <uattr name="Pin/0023"></uattr>
                <uattr name="Pin/0024"></uattr>
                <uattr name="Pin/0025"></uattr>
                <uattr name="Pin/0026"></uattr>
                <uattr name="Pin/0027"></uattr>
                <uattr name="Pin/0028"></uattr>
                <uattr name="Pin/0029"></uattr>
                <uattr name="Pin/0030"></uattr>
                <uattr name="Pin/0031"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Dynamic Power Control" enabled="0"/>
        <resource_ref name="GPIO Event Trigger" enabled="0"/>
        <resource_ref name="I2C Master" enabled="0">
            <rattr name="SCL frequency">0</rattr>
            <rattr name="SCL stretch timeout">1</rattr>
            <io_usage>
                <uattr name="SCL pin/0000"></uattr>
                <uattr name="SDA pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="ISRC" enabled="0"/>
        <resource_ref name="Math and Logic" enabled="1"/>
        <resource_ref name="Multi-Buffered Output Data Exchange" enabled="0">
            <rattr name="Buffer count">2</rattr>
            <rattr name="Indicate overflow at buffer check">1</rattr>
            <rattr name="Indicate overflow at buffer switch">0</rattr>
            <rattr name="Prevent overflow at buffer switch">1</rattr>
        </resource_ref>
        <resource_ref name="Peripheral Sharing" enabled="0"/>
        <resource_ref name="Pulse Counter" enabled="0"/>
        <resource_ref name="RTC Multi-Event Capture" enabled="0"/>
        <resource_ref name="RTC-Based Execution Scheduling" enabled="1"/>
        <resource_ref name="Reference DAC" enabled="0"/>
        <resource_ref name="Run-Time Logging" enabled="1"/>
        <resource_ref name="SPI Chip Select" enabled="0"/>
        <resource_ref name="SPI Data Transfer" enabled="0">
            <rattr name="Bit rate">0</rattr>
            <rattr name="MISO configuration when inactive">-1</rattr>
            <rattr name="MOSI configuration on initialization">0</rattr>
            <rattr name="MOSI configuration on uninitialization">0</rattr>
            <rattr name="SCLK configuration on initialization">0</rattr>
            <rattr name="SCLK configuration on uninitialization">0</rattr>
            <io_usage>
                <uattr name="MISO pin/0000"></uattr>
                <uattr name="MOSI pin/0000"></uattr>
                <uattr name="SCLK pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <resource_ref name="Signal Observation" enabled="0"/>
        <resource_ref name="System CPU Alert" enabled="1"/>
        <resource_ref name="System Event Trigger" enabled="0"/>
        <resource_ref name="TDC" enabled="0"/>
        <resource_ref name="Timer 0" enabled="0"/>
        <resource_ref name="Timer 0 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 1" enabled="0"/>
        <resource_ref name="Timer 1 Event Trigger" enabled="0"/>
        <resource_ref name="Timer 2" enabled="0"/>
        <resource_ref name="Timer 2 Event Trigger" enabled="0"/>
        <resource_ref name="UART Emulator" enabled="0">
            <rattr name="RX buffer size">64</rattr>
            <rattr name="Required idle period before enabling RX">11</rattr>
            <rattr name="TX buffer size">64</rattr>
            <io_usage>
                <uattr name="RX pin/0000"></uattr>
                <uattr name="TX pin/0000"></uattr>
            </io_usage>
        </resource_ref>
        <sccode name="event0" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="event1" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="event2" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="event3" init_power_mode="0"><![CDATA[]]></sccode>
        <sccode name="execute" init_power_mode="0"><![CDATA[macro max(maxval, val1, val2) {
    if (val1 >= val2) {
        maxval = val1;
    } else {
        maxval = val2;
    }
}

U16 powerOff = 0;
U16 powerOn = 1;
U16 waitIr = 2;
U16 common = 3;

U16 l_Uph = 0;
U16 l_Upl = 0;
U16 PirDynamicThresh = 0;
U16 condition = 0;
S16 n = 0;

l_Uph = state.Ucp + PIR_THRESHOLD;
l_Upl = state.Ucp - PIR_THRESHOLD;

if (input.isArmed != 0) {
    if (state.state == powerOff) {
        state.Downtimer = PERIOD_5S;
        state.DowntimerRun = 1;
        state.state = powerOn;
        state.Uacch = 0;
        state.Uaccl = 0;
        state.PirAveragingSamples = PIR_AVERAGING_TIME;
    }
} else {
    if (state.state != powerOff) {
        gpioSetOutput(AUXIO_O_PIR_OFF);
        state.state = powerOff;
        state.PirPulseCounter = 0;
        state.PirPulsePresense = 0;
        state.PirOutOfPipe = 0;
        cfg.CntMinusOne = 0;
        state.alarmdowntimerrun = 0;
        state.idledowntimerrun = 0;
        state.lightdowntimerrun = 0;
        state.thrdowntimerrun = 0;
        state.IKstate &= ~AP_IK_ALARM_FLAG;
    }
}

if (state.DowntimerRun != 0) {
    state.Downtimer -= 1;
    if (state.Downtimer == 0) {
        state.DowntimerRun = 0;
    }
}

adcEnableSync(ADC_REF_VDDS_REL, ADC_SAMPLE_TIME_21P3_US, ADC_TRIGGER_MANUAL);
adcSelectGpioInput(AUXIO_A_IR_OUT);
adcGenManualTrigger();
adcReadFifo(output.Upiri);

adcSelectGpioInput(AUXIO_A_LED_RED_AIN);
adcGenManualTrigger();
adcReadFifo(state.Uledi);

if (state.adcdowntimer == 0) {
    state.adcdowntimer = PERIOD_1S;
    gpioSetOutput(AUXIO_O_BT_ON_P);
    fwDelayUs(500, FW_DELAY_RANGE_1_MS);

//    adcSelectGpioInput(AUXIO_A_BATTERY);
//    adcGenManualTrigger();
//    adcReadFifo(state.Ubat);

    adcSelectGpioInput(AUXIO_A_TEMPERAT);
    adcGenManualTrigger();
    adcReadFifo(state.Ut);

    gpioClearOutput(AUXIO_O_BT_ON_P);
}
// Disable the ADC
adcDisable();

if(state.state == powerOn) {
    if (state.DowntimerRun == 0) {
        ifnot (cfg.flags & FLAG_UCP_OK) {
            fwGenAlertInterrupt();
        }
    } else {
        if (state.PirAveragingSamples != 0) {
            state.PirAveragingSamples -= 1;
            cfg.Uacc = output.Upiri;
            cfg.Uacc += state.Uaccl;
            if (cfg.Uacc < state.Uaccl) {
                state.Uacch += 1;
            }
            state.Uaccl = cfg.Uacc;
        } else {
            cfg.Uacc = state.Uacch << 9;
            cfg.Uacc += state.Uaccl >> 7;
            if (cfg.Uacc < cfg.adcWindowHigh) {
                if (cfg.Uacc > cfg.adcWindowLow) {
                    state.Ucp = cfg.Uacc;
//                    cfg.flags |= FLAG_UCP_OK;
                    gpioClearOutput(AUXIO_O_PIR_OFF);
                    state.state = waitIr;
                    state.Downtimer = PERIOD_5S;
                    state.DowntimerRun = 1;
                } else {
                    state.Uacch = 0;
                    state.Uaccl = 0;
                    state.PirAveragingSamples = PIR_AVERAGING_TIME;
                }
            } else {
                state.Uacch = 0;
                state.Uaccl = 0;
                state.PirAveragingSamples = PIR_AVERAGING_TIME;
            }
        }
    }
}else if (state.state == waitIr) {
    if (state.DowntimerRun == 0) {
        ifnot (cfg.flags & FLAG_PIR_OK) {
            fwGenAlertInterrupt();
        }
    } else {
        if (output.Upiri < cfg.adcWindowHigh) {
            if (output.Upiri > cfg.adcWindowLow) {
                cfg.flags |= FLAG_PIR_OK;
                state.state = common;
                state.Downtimer = 0;
                state.DowntimerRun = 0;
            }
        }
    }
}else if(state.state == common) {
    if (state.alarmdowntimerrun != 0) {
        state.alarmdowntimer -= 1;
        if (state.alarmdowntimer == 0) {
            state.alarmdowntimerrun = 0;
            if (AP_IK_ALARM_FLAG & state.IKstate) {
                state.PirPulseCounter -= PIR_SENS;
                state.IKstate &= ~AP_IK_ALARM_FLAG;
            }
        }
    }
    if (state.idledowntimerrun != 0) {
        state.idledowntimer -= 1;
        if (state.idledowntimer == 0) {
            state.idledowntimerrun = 0;
            if (state.PirPulseCounter > 0) {
                ifnot (AP_IK_ALARM_FLAG & state.IKstate) {
                    state.PirPulseCounter = 0;
                }
            }
        }
    }
    if (state.lightdowntimerrun != 0) {
        state.lightdowntimer -= 1;
        if (state.lightdowntimer == 0) {
            state.lightdowntimerrun = 0;
            if (state.PirPulseCounter == MINUS_ONE) {
                state.PirPulseCounter = 0;
            }
        }
    }
    if (state.thrdowntimerrun != 0) {
        state.thrdowntimer -= 1;
        if (state.thrdowntimer == 0) {
            state.thrdowntimerrun = 0;
            if (l_Upl != state.Upl) {
                state.Upl = l_Upl;
            }
            if (l_Uph != state.Uph) {
                state.Uph = l_Uph;
            }
        }
    }
    if (state.lightdowntimerrun != 0) {
        state.lightdowntimer -= 1;
        if (state.lightdowntimer == 0) {
            state.lightdowntimerrun = 0;
            if (state.PirPulseCounter == MINUS_ONE) {
                state.PirPulseCounter = 0;
            }
        }
    }
    n = state.Uledidx;
    state.aUled[n] = state.Uledi;
    n += 1;
    if (n >= ULED_BUF_SIZE) {
        n = 0;
        cfg.CntMinusOne = 1;
    }
    state.Uledidx = n;
    state.Uledmax = state.aUled[0];
    state.Uledmin = state.aUled[ULED_BUF_SIZE - 1];
    //    for (U16 n = 0; n < ULED_BUF_SIZE; n++) {
    n = ULED_BUF_SIZE - 2;
    while(n > 0) {
        if (state.Uledmax < state.aUled[n]) {
            state.Uledmax = state.aUled[n];
        }
        if (state.Uledmin > state.aUled[n]) {
            state.Uledmin = state.aUled[n];
        }
        n -= 1;
    }
    state.dUled = state.Uledmax - state.Uledmin;
    if (input.isTestMode == 0) {
        if (cfg.CntMinusOne == 1) {
            if (state.alarmdowntimerrun == 0) {
                if (state.dUled > LIGHT_THRESHOLD) {
                    if (state.PirPulseCounter <= 0) {
                        state.LightThrCounter += 1;
                        if (state.LightThrCounter <= LIGHT_ACC_THRESHOLD) {
                            if (0 == state.PirPulseCounter) {
                                state.lightdowntimer = LIGHT_RESTORE_PERIOD;
                                state.lightdowntimerrun = 1;
                                state.PirPulseCounter -= 1;
                            }
                        }
                    } else {
                        state.LightThrCounter = 0;
                    }
                } else {
                    state.LightThrCounter = 0;
                }
            }
        }
    }
    //    if (state.lightdowntimerrun == 0) {
    //        if (state.PirPulseCounter == MINUS_ONE) {
    //            state.PirPulseCounter = 0;
    //        }
    //    }
    state.Upiri2 = state.Upiri1;
    state.Upiri1 = state.Upiri;
    state.Upiri = output.Upiri;

    state.deltaU = state.Upiri - state.Ucp;
    state.deltaU1 = state.Upiri1 - state.Ucp;
    state.slope1 = state.Upiri - state.Upiri1;
    state.slope1 = (@state.slope1);
    state.slope2 = state.Upiri1 - state.Upiri2;
    state.slope2 = (@state.slope2);
    state.maxslope = state.slope1;
    if (state.maxslope < state.slope2) {
        state.maxslope = state.slope2;
    }
    state.absdU = (@state.deltaU);
    state.absdU1 = (@state.deltaU1);

    if (state.PirOutOfPipe != 0) {
        if (state.deltaU >= 0) {
            if (state.deltaU1 < 0) {
                PirDynamicThresh = (state.maxUl + 1) >> 1;
                if (PirDynamicThresh > PIR_THRESHOLD) {
                    state.Uph = state.Ucp + PirDynamicThresh;
                } else {
                    state.Uph = l_Uph;
                }
                state.thrdowntimer = PIR_IDLE_PERIOD;
                state.thrdowntimerrun = 1;
                state.Upl = l_Upl;
                state.PirOutOfPipe = 0;
                state.maxUh = 0;
                state.maxUl = 0;
            }
        } else {
            if (state.deltaU1 >= 0) {
                PirDynamicThresh = (state.maxUh + 1) >> 1;
                if (PirDynamicThresh > PIR_THRESHOLD) {
                    state.Upl = state.Ucp - PirDynamicThresh;
                } else {
                    state.Upl = l_Upl;
                }
                state.thrdowntimer = PIR_IDLE_PERIOD;
                state.thrdowntimerrun = 1;
                state.Uph = l_Uph;
                state.PirOutOfPipe = 0;
                state.maxUh = 0;
                state.maxUl = 0;
            }
        }
        if (state.absdU < PIR_NOISE_THRESHOLD) {
            if (state.maxUl >= state.maxUh) {
                PirDynamicThresh = (state.maxUl + 1) >> 1;
                if (PirDynamicThresh > PIR_THRESHOLD) {
                    state.Uph = state.Ucp + PirDynamicThresh;
                } else {
                    state.Uph = l_Uph;
                }
                state.Upl = l_Upl;
            } else {
                PirDynamicThresh = (state.maxUh + 1) >> 1;
                if (PirDynamicThresh > PIR_THRESHOLD) {
                    state.Upl = state.Ucp - PirDynamicThresh;
                } else {
                    state.Upl = l_Upl;
                }
                state.Uph = l_Uph;
            }
            state.thrdowntimer = PIR_IDLE_PERIOD;
            state.thrdowntimerrun = 1;
            state.PirOutOfPipe = 0;
            state.maxUh = 0;
            state.maxUl = 0;
        }
    }
    if (state.absdU > PIR_THRESHOLD) {
        if (state.absdU1 <= PIR_THRESHOLD) {
            state.PirOutOfPipe = 1;
        }
        if (state.deltaU >= 0) {
            if (state.deltaU1 < 0) {
                state.PirOutOfPipe = 1;
            }
        } else {
            if (state.deltaU1 >= 0) {
                state.PirOutOfPipe = 1;
            }
        }
    }

    condition = 0;
    if (state.deltaU >= 0) {
        if (state.deltaU1 < 0) {
            state.PirPulsePresense = 0;
            condition = 1;
        }
    } else {
        if (state.deltaU1 >= 0) {
            state.PirPulsePresense = 0;
            condition = 1;
        }
    }

    if (condition == 0) {
        if (state.absdU < PIR_NOISE_THRESHOLD) {
            state.PirPulsePresense = 0;
        } else {
            if (state.deltaU >= 0) {
                condition = 0;
                if (state.Upiri > state.Uph) {
                    if (state.Upiri1 <= state.Uph) {
                        condition = 1;
                    }
                }
                // ?????? ???? ?????
                if (condition == 1) {
                    // (state.Upiri > state.Uph) && (state.Upiri1 <= state.Uph)
                    condition = 0;
                    if (state.maxslope < PIR_SLOPE_THRESHOLD) {
                        if (state.PirPulsePresense == 0) {
                            ifnot (state.IKstate & AP_IK_ALARM_FLAG) {
                                state.PirPulseCounter += 1;
                                if (input.isTestMode == 1) {
                                    fwGenAlertInterrupt();
                                }
                            }
                            state.idledowntimer = PIR_IDLE_PERIOD;
                            state.idledowntimerrun = 1;
                            state.PirPulsePresense = 1;
                        }
                    }
                    state.maxUh = state.absdU;
                    state.maxUl = 0;
                } else {
                    if (state.absdU > state.maxUh) {
                        if (state.PirPulsePresense == 1) {
                            state.maxUh = state.absdU;
                            state.maxUl = 0;
                        }
                    }
                }
            } else {
                // state.deltaU < 0
                condition = 0;
                if (state.Upiri < state.Upl) {
                    if (state.Upiri1 >= state.Upl) {
                        condition = 1;
                    }
                }
                if (condition == 1) {
                    condition = 0;
                    if (state.maxslope < PIR_SLOPE_THRESHOLD) {
                        if (state.PirPulsePresense == 0) {
                            ifnot (state.IKstate & AP_IK_ALARM_FLAG) {
                                state.PirPulseCounter += 1;
                                if (input.isTestMode == 1) {
                                    fwGenAlertInterrupt();
                                }
                            }
                            state.idledowntimer = PIR_IDLE_PERIOD;
                            state.idledowntimerrun = 1;
                            state.PirPulsePresense = 1;
                        }
                    }
                    state.maxUl = state.absdU;
                    state.maxUh = 0;
                } else {
                    if (state.absdU > state.maxUl) {
                        if (state.PirPulsePresense == 1) {
                            state.maxUl = state.absdU;
                            state.maxUh = 0;
                        }
                    }
                }
            }
        }
    }
    if (state.PirPulseCounter >= PIR_SENS) {
        ifnot (state.IKstate & AP_IK_ALARM_FLAG) {
            if (input.isTestMode != 0) {
                state.alarmdowntimer = 1;
            } else {
                fwGenAlertInterrupt();
                state.alarmdowntimer = PIR_ALARM_TIME;
            }
            state.alarmdowntimerrun = 1;
            state.IKstate |= AP_IK_ALARM_FLAG;
        }
    }
}


output.Upirav = state.Ucp;
output.Uph = state.Uph;
output.Upl = state.Upl;
output.Uledi = state.Uledi;
output.dUled = state.dUled;
output.LightThrCounter10 = state.LightThrCounter << 3;
output.LightThrCounter10 += state.LightThrCounter << 1;
output.PirPulseCounter = state.PirPulseCounter;


if (input.isLogMode == 1) {
    fwGenAlertInterrupt();
    input.count = 0;
}

// Schedule the next execution
fwScheduleTask(1);

// Run-time logging: Log the output data structure
rtlLogStructs(BV_RTL_LOG_OUTPUT);]]></sccode>
        <sccode name="initialize" init_power_mode="0"><![CDATA[//U16 t5S = 250;     //5S start time (250 for 20 ms step)
U16 powerOff = 0;
//U16 powerOn = 1;
//U16 waitIr = 2;
//U16 common = 3;

// Select ADC input
adcSelectGpioInput(AUXIO_A_IR_OUT);

gpioSetOutput(AUXIO_O_PIR_OFF);

state.PirPulseCounter = 0;
state.Ucp = 2000;
state.Uph = state.Ucp + PIR_THRESHOLD;
state.Upl = state.Ucp - PIR_THRESHOLD;
cfg.adcWindowHigh = state.Ucp + PIR_NOISE_THRESHOLD;
cfg.adcWindowLow = state.Ucp - PIR_NOISE_THRESHOLD;

state.adcdowntimer = PERIOD_1S;
state.Downtimer = 0;
state.DowntimerRun = 0;
state.state = powerOff;

//scifStartRtcTicks(0x00010000, 0x00002000);

// Schedule the first execution
fwScheduleTask(1);]]></sccode>
        <sccode name="terminate" init_power_mode="0"><![CDATA[]]></sccode>
        <event_trigger active_count="1">0,1,2,3</event_trigger>
        <tt_iter>run_execute</tt_iter>
        <tt_struct>output.Upiri,state.LightThrCounter,state.PirPulseCounter,state.Uledi,state.Upiri,state.dUled,state.state</tt_struct>
        <rtl_struct></rtl_struct>
        <rtl_task_sel en="1" struct_log_list="output"/>
    </task>
</project>
